#+TITLE: Lecture 2
#+SETUPFILE: ../template-1.org
Created on 2020-07-13/02:21

* Scripting
** Defining Variables
+ To define a variable, you can use ~foo=bar~.
  #+BEGIN_SRC shell
foo=bar
echo $foo
  #+END_SRC

  #+RESULTS:
  : bar

  : RESULTS:
  : bar

+ ~foo = bar~ would not work as it is the equivalent as ~foo~ calling upon the ===, and =bar= arguments.

  + Strings can be desginated using ~'~ and ~"~.
    + ~'~ is used for literal strings and will not subsitute variables.
    + ~"~ will be able to subsitute variables.
      
  #+BEGIN_SRC shell
    foo=bar
    echo "$foo"
    echo '$foo'
  #+END_SRC

  #+RESULTS:
  | bar  |
  | $foo |

       : RESULTS:
        | bar  |
        | $foo |
** Functions
+ Bash supports control flow techniques such as ~if~, ~case~, and ~for~.
+ Bash also has functions which take arguments and operate them.

  #+BEGIN_SRC shell
mcd () {
    mkdir -p "$1"
cd "$1"
}
  #+END_SRC

  #+RESULTS:

+ In this scenario, ~$1~ is the first argument to the function.
    + This function will make a directory with the name of the argument ~$1~ and ~cd~ into that folder.

      
+ In bash, there are a number of relevant variables.
  | $0       | Name of script                                            |
  | $1 to $9 | Arguments to the script                                   |
  | $@       | All the arguments                                         |
  | $#       | Number of arguments                                       |
  | $?       | Return code of the previous command                       |
  | $$       | Process identification number (PID) of the current script |
  | !!       | Entire last command, including arguments.                 |
  | $_       | Last argument from previous command.                      |

+ A full list can be found [[https://www.tldp.org/LDP/abs/html/special-chars.html][here.]]

** Error Codes and Outputs
+ A return code of =0= means that the previous function ran *without* any issues.
+ Return code of =1= means there *was* an issue.

  
+ /True/ will return error code =0=.
+ /False/ will return error code =1=.


+ This way, error codes can be used conditionally to execute commands.


  + =||= is equivalent to =or=. If error code returns one, it will run the second command.
    + The second command will not run if the first command did not return an error code.
      #+BEGIN_SRC shell
    false || echo "Oops fail"
    true || echo "This prints nothing"
      #+END_SRC
      : RESULTS:
      : Oops fail

  + Similarly ~&&~ symbolizes =and=. If the first command runs successfully, the second will too.
    + If the first command returns an error code, the second will not run.
    #+BEGIN_SRC shell
true && echo "Prints"
    #+END_SRC

    : RESULTS:
    : Prints

    #+BEGIN_SRC shell
false && echo "Doesn't print"
    #+END_SRC

    : RESULTS:
+ The usage of ~;~ will always run the next command.

+ The output of a command can be stored within a variable using:
  #+BEGIN_SRC shell
foo=$(pwd)
echo "We are in $(pwd)"
echo "We are in $foo"
  #+END_SRC

  : RESULTS:
  | We | are | in | /Users/johnmao/johnrmao.github.io/org/MissingMIT |
  | We | are | in | /Users/johnmao/johnrmao.github.io/org/MissingMIT |

** Substitutions

+ To feed the output of a command as a variable, use /command subsitution./

  + ~$( CMD )~ will execute =CMD= and substitute ~$( CMD )~ with the output.

+ There is similar feature known as /process subsitution./

  + ~<( CMD )~ will execute =CMD= and place the output within a temporary file, replacing ~<()~ with that file's name.

+ An example of what's mentioned above would be:
  #+BEGIN_SRC shell
echo "Starting program at $(date)" # The current date will replace $(date) in this scenario
echo "Running program $0 with $# arguments with pid $$"

for file in "$@"; do # -ne is comparing to see if $@ does not equal 0
    grep foobar "$file" > /dev/null 2> /dev/null
    # if nothing is found, grep returns exit status 1
    # redirected STDOUT and STDERR to null register as they are irrelevant
    if [[ $? -ne 0 ]]; then
        echo "File $file does not have any foobar, adding one"
        echo "# foobar" >> "$file"
    fi
done
  #+END_SRC
+ Here, using ~-ne~ we can test whether ~$?~ was not equal to 0.
+ The script above will take arguments and ~grep~ them for "foobar" and will add a "foobar" if it was not detected.

  
* Tools

* Search

* Navigation
* Exercises
